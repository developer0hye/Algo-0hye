# 트리

이 문제 쉽지않다.

기본적으로 문제 설명을 이해하는데도 시간이 좀 걸렸고, 무엇보다 문제를 풀기 위한 선행 지식이 없었기에 구현에도 오랜 시간이 필요했다.

이 문제를 해결하기 위해서는 어느정도의 선행 지식이 필요하다.

### 선행 지식

- 인접 리스트: 트리를 구성하는데 필요하다. 나는 이를 vector<vector<int>> 를 사용하여 구현하였다. 
그런데 트리는 단방향 연결이니까 양방향 연결로 구현할 필요는 없다.

- BFS: leaf 노드를 탐색하는데 필요하다.

구현하기에 앞서 우선 입력에 따라 트리가 어떻게 구성되는지를 파악해야한다.


그림 옆에 숫자들은 입력이고, 초록색으로 강조된 노드는 리프노드, 분홍색으로 강조된 노드는 셋째 줄 입력에 의해 제거되는 노드를 나타낸다.

[그림]()



마지막에 

```
5

3 0 0 -1 1

2
```

이런 입력예시가 있는데, 이 입력은 0번 노드가 항상 루트 노드가 아닐 수 있음을 알리기 위해 작성된 그림이다.

그림을 보면 이제 당신이 뭘해야 할지를 느꼈을 것이다.

1. 입력에 따라 그에 맞는 트리를 나타내야한다.

2. 3번째 입력에 맞춰 노드의 자식 노드들을 모두 삭제한다.

3. 루트 노드부터 BFS 로 각 노드를 방문한다.

3.1 방문하고자 하는 노드가 3번째 입력에 의해 제거되는 노드가 아니면, 해당 노드들을 탐색해가며 자식 노드가 있는지 없는지를 판별하고 없다면 Leaf 노드로 판단하여
갯수를 센다!

## 고찰

BFS 의 개념은 익히들어 알고있었는데 이를 실제로 문제 풀이에 이용하려니까 막상 어떻게 적용해야할지 감이 오지 않았다.

하지만 계속 문제를 읽어보고 다른 사람들의 풀이법을 찾아보니 왜 BFS 를 이용해야하는지 감이 잡혔고 어떻게 구현하면 

되겠다는 것들이 머리 속에 촵촵 정리되었다.
